//
//  SQportal.hpp
//  
//  Class that reads the information of the tensor contractions generated by the Fafnir engine.
//
//  Created by Masaaki Saitow on 13/10/17.
//  Copyright (c) 2012 Masaaki Saitow. All rights reserved.
//

#pragma once

#include <cstring>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <fstream>
#include <Femto.hpp>
#include <SQindex.hpp>
#include <SQtensor.hpp>
#include <SQterm.hpp>
#include <SQbinary.hpp>
#include <SQcont.hpp>
#include <SQreaktor.hpp>
#include <SQints.hpp>

namespace Femto { namespace Portal {

    // --------------------------------------------------
    // Predefined names for the MO indices
    // --------------------------------------------------
    inline SQcont<std::string> coreNonDummy(){ return SQcont<std::string>("w", "x", "y", "z");           }
    inline SQcont<std::string>  actNonDummy(){ return SQcont<std::string>("i", "j", "k", "l", "m", "n"); }
    inline SQcont<std::string> virtNonDummy(){ return SQcont<std::string>("a", "b", "c", "d");           }

    inline SQcont<std::string> coreDummy(){ return SQcont<std::string>("c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9"); } 
    inline SQcont<std::string>  actDummy(){ return SQcont<std::string>("a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9"); }  
    inline SQcont<std::string> virtDummy(){ return SQcont<std::string>("v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9"); } 

    // --------------------------------------------------
    // Predefined names for the tensors and coefficients
    // --------------------------------------------------
    inline SQcont<std::string> t_t2Amps  (){ return SQcont<std::string>("@T2");                      }
    inline SQcont<std::string> t_s2Amps  (){ return SQcont<std::string>("@S2");                      }
    inline SQcont<std::string> t_h1      (){ return SQcont<std::string>("@h1");                      }
    inline SQcont<std::string> t_h2      (){ return SQcont<std::string>("@V2");                      }
    inline SQcont<std::string> t_Rdms    (){ return SQcont<std::string>("@D1", "@D2", "@D3", "@D4"); }
    inline SQcont<std::string> t_Cum     (){ return SQcont<std::string>("@C2");                      }
    inline SQcont<std::string> t_C5      (){ return SQcont<std::string>("@C5");                      }
    inline SQcont<std::string> t_C4      (){ return SQcont<std::string>("@C4");                      }
    inline SQcont<std::string> t_C6      (){ return SQcont<std::string>("@C6");                      }
    inline SQcont<std::string> t_CasFock (){ return SQcont<std::string>("@cF");                      }
    inline SQcont<std::string> t_CoreFock(){ return SQcont<std::string>("@Fcore");                   }
    inline SQcont<std::string> t_JInt    (){ return SQcont<std::string>("@h4Int_");                  } // h4_int
    inline SQcont<std::string> t_KInt    (){ return SQcont<std::string>("@h5Int_");                  } // h5_int
    inline SQcont<std::string> c_Ecore   (){ return SQcont<std::string>("Ecore");                    }
    inline SQcont<std::string> c_Ecas    (){ return SQcont<std::string>("Ecas");                     }
    inline SQcont<std::string> t_Null    (){ return SQcont<std::string>("@_NULL_");                  }
    inline SQcont<std::string> c_Unit    (){ return SQcont<std::string>("_UNI_");                    }

    // Intermediate tensors
    inline bool is_Interm(const std::string name)
    { 
      if(name.at(0) == '@' && name.at(1) == 'W' /*&& atoi(num.c_str())*/) return true;
      else                                                                return false;
    }

    // -----------------------------------------
    // Small Utilities    
    // -----------------------------------------
    // Calcate the distance between two indices of the given string object
    inline size_t calc_distance(size_t adv, size_t retard)
    { return std::string::npos - (adv > retard ? retard : adv) + (adv < retard ? retard : adv); }

    // *********************************************************
    // 
    // *********************************************************
    inline Femto::Core::SQtensor Cumulant(const std::vector<Femto::Core::SQindex*> indices)
    { 
      if(indices.size() != 4) std::cout << "Can't make 2-body cumulant " << std::endl;
      Femto::Core::RDM temp(indices);
      IIvector myperm(temp.get_perms());
      Ivector mycoeff;
      for(auto p = myperm.begin();p != myperm.end();++p) mycoeff.push_back(1);
      return Femto::Core::SQtensor("C2", temp.get_indices(), make_pair(myperm, mycoeff));
    }
    
    // *********************************************************
    // 
    // *********************************************************
    inline Femto::Core::SQtensor MCumulant(const std::vector<Femto::Core::SQindex*> indices)
    { 
      Femto::Core::SQtensor temp(Cumulant(indices));
      IIvector myperm(temp.get_perms());
      Ivector mycoeff;
      for(auto p = myperm.begin();p != myperm.end();++p) mycoeff.push_back(1);
      return Femto::Core::SQtensor("C2", temp.get_indices(), make_pair(myperm, mycoeff), true, Femto::Mulliken);
    }
    
    // *********************************************************
    // 
    // *********************************************************
    inline Femto::Core::SQtensor MRDM(const std::vector<Femto::Core::SQindex*> indices)
    {
      Femto::Core::RDM temp(indices);
      temp.convertD2M();
      IIvector myperm(temp.get_perms());
      Ivector mycoeff;
      for(auto p = myperm.begin();p != myperm.end();++p) mycoeff.push_back(1);
      return Femto::Core::SQtensor(temp.get_name(), indices, make_pair(myperm, mycoeff), true, Femto::Mulliken);
    }
    
    // *********************************************************
    // 
    // *********************************************************
    inline Femto::Core::SQtensor Mtensor(const std::string &name, const std::vector<Femto::Core::SQindex*> indices, const Symmetry &symm)
    {
      Femto::Core::SQtensor temp(name, indices, symm);
      temp.convertD2M();
      IIvector myperm(temp.get_perms());
      Ivector mycoeff;
      for(auto p = myperm.begin();p != myperm.end();++p) mycoeff.push_back(1);
      return Femto::Core::SQtensor(name, indices, make_pair(myperm, mycoeff), true, Femto::Mulliken);
    }


    // *********************************************************
    // 
    // *********************************************************
    enum version {OLD=0, NEW=1, NEW2=2}; // Represents the version of the contraction format

    class SQportal{
  
    public: 
      SQportal(const std::string &file_name, const std::string &ltensorName, Femto::notation=Femto::Dirac);
      void transportContractions(std::vector<std::vector<Femto::Core::SQbinary> > &theBins, Femto::Portal::version myVersion=OLD);
      Femto::Core::SQbinary readContraction    (std::string myContraction) const; // The simplest imeplementation with many limitations
      Femto::Core::SQbinary readContractionNew (std::string myContraction) const; // The second simplest
      Femto::Core::SQbinary readContractionNew2(std::string myContraction) const; // The third simplest
      Femto::Core::SQindex readIndex(std::string myIndex) const;
      Femto::Core::SQterm readTensor(std::string myTensor) const; // A function that returns one-tensor term

      void transformD2M_INT_RDM(std::vector<std::vector<Femto::Core::SQbinary> > &theBins, bool doMask = true);
      
    private:
      std::string Faf_name_;
      std::string ltensorName_;
      Femto::notation myNotation_;
    };

}} // Femto::Portal
